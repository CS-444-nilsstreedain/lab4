# Lab 3
## 1. What is the purpose of having an individual handler function for each exception/interrupt? (i.e., if all exceptions/interrupts were delivered to the same handler, what feature that exists in the current implementation could not be provided?)
Using individual handler functions for each exception or interrupt is important for effective error handling. Each type of exception or interrupt typically signifies a different kind of issue, requiring a different response. For example, a memory access violation needs a different approach than a division by zero error. Individual handlers allow for targeted responses, making the code clearer, easier to maintain, and more robust. They also ensure better resource management by allowing tailored handling of specific issues. A single generic handler would be less effective, potentially leading to complex, less reliable, and harder-to-maintain code.

## 2. Did you have to do anything to make the user/softint program behave correctly? The grade script expects it to produce a general protection fault (trap 13), but softint’s code says int $14. Why should this produce interrupt vector 13? What happens if the kernel actually allows softint’s int $14 instruction to invoke the kernel’s page fault handler (which is interrupt vector 14)?
No, there was no need to make any changes to the softint program for it to behave correctly. The program is designed to generate a general protection fault (interrupt vector 13), although it contains a call for int $14 (a page fault interrupt). This discrepancy is due to security measures that prevent user programs from directly invoking certain interrupts. If the kernel permitted softint to trigger the page fault handler directly, it could lead to security vulnerabilities, as users could exploit this to execute malicious code with kernel privileges. Thus, the system interprets the int $14 call as a privilege violation and triggers a general protection fault instead.

## 3. The break point test case will either generate a break point exception or a general protection fault depending on how you initialized the break point entry in the IDT (i.e., your call to SETGATE from trap_init). Why? How do you need to set it up in order to get the breakpoint exception to work as specified above and what incorrect setup would cause it to trigger a general protection fault?
The behavior of the breakpoint test case is determined by the initialization settings of the breakpoint entry in the IDT. This setup is important because it defines the privilege level required to trigger the breakpoint trap handler. For the breakpoint exception to operate as intended, the DPL must be set to 3 during the initialization process. This setting allows user mode to invoke the breakpoint trap handler. If the DPL is incorrectly set to 0, it restricts the privilege to invoke the trap handler to kernel mode. An attempt to invoke the trap handler from user mode in this scenario will lead to a general protection fault. This is due to the insufficient privilege level assigned through the IDT setup.

## 4. What do you think is the point of these mechanisms, particularly in light of what the user/softint test program does?
The primary purpose of these mechanisms is to protect the kernel and other processes from any unauthorized or unintended interactions by user space processes, particularly in scenarios involving interrupts and exceptions. They ensure that user applications can only access the kernel through specific, controlled entry points. These entry points include checks for privilege levels, which are important for maintaining system integrity and security. In the case of the user/softint test program, if it attempts to provoke a page fault, an operation that requires kernel-level privileges, the system's protective measures will trigger a general protection fault instead. This response prevents unauthorized access to kernel privileges by user applications, thus maintaining the robustness and security of the system.
